From f9082288382b7f3bc600bdb90c114625fc85ba14 Mon Sep 17 00:00:00 2001
From: Juan Gutierrez <juan.gutierrez@nxp.com>
Date: Mon, 26 Feb 2018 23:15:27 +0000
Subject: [PATCH 1/3] drivers: integrate led, spha and tfa drivers for 8M

Signed-off-by: Juan Gutierrez <juan.gutierrez@nxp.com>
---
 arch/arm64/configs/defconfig               |   5 +
 drivers/leds/Kconfig                       |   9 +
 drivers/leds/Makefile                      |   1 +
 drivers/leds/leds-pca995x.c                | 447 +++++++++++++++++++++++++++++
 include/linux/platform_data/leds-pca995x.h |  42 +++
 sound/soc/codecs/Kconfig                   |   5 +
 sound/soc/codecs/Makefile                  |   2 +
 sound/soc/codecs/sph0645.c                 |  76 +++++
 sound/soc/fsl/Kconfig                      |  13 +
 sound/soc/fsl/Makefile                     |   4 +
 sound/soc/fsl/imx-sph0645.c                | 407 ++++++++++++++++++++++++++
 sound/soc/fsl/imx-tfa98xx.c                | 430 +++++++++++++++++++++++++++
 12 files changed, 1441 insertions(+)
 create mode 100644 drivers/leds/leds-pca995x.c
 create mode 100644 include/linux/platform_data/leds-pca995x.h
 create mode 100644 sound/soc/codecs/sph0645.c
 create mode 100644 sound/soc/fsl/imx-sph0645.c
 create mode 100644 sound/soc/fsl/imx-tfa98xx.c

diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index fafeec5..49584e2 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -638,3 +638,8 @@ CONFIG_CRYPTO_GHASH_ARM64_CE=y
 CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
 CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
 CONFIG_CRYPTO_CRC32_ARM64=y
+CONFIG_LEDS_PCA995X=y
+CONFIG_SND_SOC_IMX_TFA98XX=y
+CONFIG_SND_SOC_IMX_SPH0645=y
+CONFIG_SND_SOC_SPH0645=y
+
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index 7a628c6..563b432 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -361,6 +361,15 @@ config LEDS_PCA963X
 	  LED driver chip accessed via the I2C bus. Supported
 	  devices include PCA9633 and PCA9634
 
+config LEDS_PCA995X
+       tristate "LED support for PCA995x I2C chip"
+       depends on LEDS_CLASS
+      depends on I2C
+       help
+         This option enables support for LEDs connected to the PCA995x
+         LED driver chip accessed via the I2C bus. Supported
+         devices include PCA9955 and PCA9952
+
 config LEDS_WM831X_STATUS
 	tristate "LED support for status LEDs on WM831x PMICs"
 	depends on LEDS_CLASS
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index 3965070..9d3c3d4 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -43,6 +43,7 @@ obj-$(CONFIG_LEDS_OT200)		+= leds-ot200.o
 obj-$(CONFIG_LEDS_FSG)			+= leds-fsg.o
 obj-$(CONFIG_LEDS_PCA955X)		+= leds-pca955x.o
 obj-$(CONFIG_LEDS_PCA963X)		+= leds-pca963x.o
+obj-$(CONFIG_LEDS_PCA995X)              += leds-pca995x.o
 obj-$(CONFIG_LEDS_DA903X)		+= leds-da903x.o
 obj-$(CONFIG_LEDS_DA9052)		+= leds-da9052.o
 obj-$(CONFIG_LEDS_WM831X_STATUS)	+= leds-wm831x-status.o
diff --git a/drivers/leds/leds-pca995x.c b/drivers/leds/leds-pca995x.c
new file mode 100644
index 0000000..5d43c69
--- /dev/null
+++ b/drivers/leds/leds-pca995x.c
@@ -0,0 +1,447 @@
+/*
+ * Copyright 2011 bct electronic GmbH
+ * Copyright 2013 Qtechnology/AS
+ *
+ * Author: Peter Meerwald <p.meerwald@bct-electronic.com>
+ * Author: Ricardo Ribalda <ricardo.ribalda@gmail.com>
+ *
+ * Based on leds-pca963x.c
+ *
+ * This file is subject to the terms and conditions of version 2 of
+ * the GNU General Public License.  See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ * LED driver for the PCA995x
+ * 
+ *
+ * Note that hardware blinking violates the leds infrastructure driver
+ * interface since the hardware only supports blinking all LEDs with the
+ * same delay_on/delay_off rates.  That is, only the LEDs that are set to
+ * blink will actually blink but all LEDs that are set to blink will blink
+ * in identical fashion.  The delay_on/delay_off values of the last LED
+ * that is set to blink will be used for all of the blinking LEDs.
+ * Hardware blinking is disabled by default but can be enabled by setting
+ * the 'blink_type' member in the platform_data struct to 'PCA963X_HW_BLINK'
+ * or by adding the 'nxp,hw-blink' property to the DTS.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <linux/leds.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/platform_data/leds-pca995x.h>
+
+/* LED select registers determine the source that drives LED outputs */
+#define PCA963X_LED_OFF		0x0	/* LED driver off */
+#define PCA963X_LED_ON		0x1	/* LED driver on */
+#define PCA963X_LED_PWM		0x2	/* Controlled through PWM */
+#define PCA963X_LED_GRP_PWM	0x3	/* Controlled through PWM/GRPPWM */
+
+#define PCA963X_MODE2_DMBLNK	0x20	/* Enable blinking */
+
+#define PCA963X_MODE1		0x00
+#define PCA963X_MODE2		0x01
+#define PCA963X_PWM_BASE	0x0A
+#define PCA963X_IREFALL		0x43
+
+enum pca995x_type {
+	pca9955,
+};
+
+struct pca995x_chipdef {
+	u8			grppwm;
+	u8			grpfreq;
+	u8			ledout_base;
+	int			n_leds;
+};
+
+static struct pca995x_chipdef pca995x_chipdefs[] = {
+
+	[pca9955] = {
+		.grppwm		= 0x08,
+		.grpfreq	= 0x09,
+		.ledout_base	= 0x02,
+		.n_leds  	= 16,
+		},
+	};
+
+/* Total blink period in milliseconds */
+#define PCA963X_BLINK_PERIOD_MIN	42
+#define PCA963X_BLINK_PERIOD_MAX	10667
+
+static const struct i2c_device_id pca995x_id[] = {
+	{ "pca9955", pca9955 },
+	{ }
+};
+
+
+MODULE_DEVICE_TABLE(i2c, pca995x_id);
+
+enum pca995x_cmd {
+	BRIGHTNESS_SET,
+	BLINK_SET,
+};
+
+struct pca995x_led;
+
+struct pca995x {
+	struct pca995x_chipdef *chipdef;
+	struct mutex mutex;
+	struct i2c_client *client;
+	struct pca995x_led *leds;
+};
+
+struct pca995x_led {
+	struct pca995x *chip;
+	struct work_struct work;
+	enum led_brightness brightness;
+	struct led_classdev led_cdev;
+	int led_num; /* 0 .. 15 potentially */
+	enum pca995x_cmd cmd;
+	char name[32];
+	u8 gdc;
+	u8 gfrq;
+};
+
+static void pca995x_brightness_work(struct pca995x_led *pca995x)
+{
+	u8 ledout_addr = pca995x->chip->chipdef->ledout_base
+		+ (pca995x->led_num / 4);
+	u8 ledout;
+	int shift = 2 * (pca995x->led_num % 4);
+	u8 mask = 0x3 << shift;
+
+	mutex_lock(&pca995x->chip->mutex);
+	ledout = i2c_smbus_read_byte_data(pca995x->chip->client, ledout_addr);
+	switch (pca995x->brightness) {
+	case LED_FULL:
+		i2c_smbus_write_byte_data(pca995x->chip->client, ledout_addr,
+			(ledout & ~mask) | (PCA963X_LED_ON << shift));
+		break;
+	case LED_OFF:
+		i2c_smbus_write_byte_data(pca995x->chip->client, ledout_addr,
+			ledout & ~mask);
+		break;
+	default:
+		i2c_smbus_write_byte_data(pca995x->chip->client,
+			PCA963X_PWM_BASE + pca995x->led_num,
+			pca995x->brightness);
+		i2c_smbus_write_byte_data(pca995x->chip->client, ledout_addr,
+			(ledout & ~mask) | (PCA963X_LED_PWM << shift));
+		break;
+	}
+	mutex_unlock(&pca995x->chip->mutex);
+}
+
+static void pca995x_blink_work(struct pca995x_led *pca995x)
+{
+	u8 ledout_addr = pca995x->chip->chipdef->ledout_base +
+		(pca995x->led_num / 4);
+	u8 ledout;
+	u8 mode2 = i2c_smbus_read_byte_data(pca995x->chip->client,
+							PCA963X_MODE2);
+	int shift = 2 * (pca995x->led_num % 4);
+	u8 mask = 0x3 << shift;
+
+	i2c_smbus_write_byte_data(pca995x->chip->client,
+			pca995x->chip->chipdef->grppwm,	pca995x->gdc);
+
+	i2c_smbus_write_byte_data(pca995x->chip->client,
+			pca995x->chip->chipdef->grpfreq, pca995x->gfrq);
+
+	if (!(mode2 & PCA963X_MODE2_DMBLNK))
+		i2c_smbus_write_byte_data(pca995x->chip->client, PCA963X_MODE2,
+			mode2 | PCA963X_MODE2_DMBLNK);
+
+	mutex_lock(&pca995x->chip->mutex);
+	ledout = i2c_smbus_read_byte_data(pca995x->chip->client, ledout_addr);
+	if ((ledout & mask) != (PCA963X_LED_GRP_PWM << shift))
+		i2c_smbus_write_byte_data(pca995x->chip->client, ledout_addr,
+			(ledout & ~mask) | (PCA963X_LED_GRP_PWM << shift));
+	mutex_unlock(&pca995x->chip->mutex);
+}
+
+static void pca995x_work(struct work_struct *work)
+{
+	struct pca995x_led *pca995x = container_of(work,
+		struct pca995x_led, work);
+
+	switch (pca995x->cmd) {
+	case BRIGHTNESS_SET:
+		pca995x_brightness_work(pca995x);
+		break;
+	case BLINK_SET:
+		pca995x_blink_work(pca995x);
+		break;
+	}
+}
+
+static void pca995x_led_set(struct led_classdev *led_cdev,
+	enum led_brightness value)
+{
+	struct pca995x_led *pca995x;
+
+	pca995x = container_of(led_cdev, struct pca995x_led, led_cdev);
+
+	pca995x->cmd = BRIGHTNESS_SET;
+	pca995x->brightness = value;
+
+	/*
+	 * Must use workqueue for the actual I/O since I2C operations
+	 * can sleep.
+	 */
+	schedule_work(&pca995x->work);
+}
+
+static int pca995x_blink_set(struct led_classdev *led_cdev,
+		unsigned long *delay_on, unsigned long *delay_off)
+{
+	struct pca995x_led *pca995x;
+	unsigned long time_on, time_off, period;
+	u8 gdc, gfrq;
+
+	pca995x = container_of(led_cdev, struct pca995x_led, led_cdev);
+
+	time_on = *delay_on;
+	time_off = *delay_off;
+
+	/* If both zero, pick reasonable defaults of 500ms each */
+	if (!time_on && !time_off) {
+		time_on = 500;
+		time_off = 500;
+	}
+
+	period = time_on + time_off;
+
+	/* If period not supported by hardware, default to someting sane. */
+	if ((period < PCA963X_BLINK_PERIOD_MIN) ||
+	    (period > PCA963X_BLINK_PERIOD_MAX)) {
+		time_on = 500;
+		time_off = 500;
+		period = time_on + time_off;
+	}
+
+	/*
+	 * From manual: duty cycle = (GDC / 256) ->
+	 *	(time_on / period) = (GDC / 256) ->
+	 *		GDC = ((time_on * 256) / period)
+	 */
+	gdc = (time_on * 256) / period;
+
+	/*
+	 * From manual: period = ((GFRQ + 1) / 24) in seconds.
+	 * So, period (in ms) = (((GFRQ + 1) / 24) * 1000) ->
+	 *		GFRQ = ((period * 24 / 1000) - 1)
+	 */
+	gfrq = (period * 24 / 1000) - 1;
+
+	pca995x->cmd = BLINK_SET;
+	pca995x->gdc = gdc;
+	pca995x->gfrq = gfrq;
+
+	/*
+	 * Must use workqueue for the actual I/O since I2C operations
+	 * can sleep.
+	 */
+	schedule_work(&pca995x->work);
+
+	*delay_on = time_on;
+	*delay_off = time_off;
+
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_OF)
+static struct pca995x_platform_data *
+pca995x_dt_init(struct i2c_client *client, struct pca995x_chipdef *chip)
+{
+	struct device_node *np = client->dev.of_node, *child;
+	struct pca995x_platform_data *pdata;
+	struct led_info *pca995x_leds;
+	int count;
+
+
+	pr_info("ALL \n");
+	count = of_get_child_count(np);
+	if (!count || count > chip->n_leds)
+		return ERR_PTR(-ENODEV);
+	pr_info("ALL 0\n");
+	pca995x_leds = devm_kzalloc(&client->dev,
+			sizeof(struct led_info) * chip->n_leds, GFP_KERNEL);
+	if (!pca995x_leds)
+		return ERR_PTR(-ENOMEM);
+
+	pr_info("ALL 1\n");
+	for_each_child_of_node(np, child) {
+		struct led_info led = {};
+		u32 reg;
+		int res;
+
+		res = of_property_read_u32(child, "reg", &reg);
+		if ((res != 0) || (reg >= chip->n_leds))
+			continue;
+		pr_info("ALL 2\n");
+
+		led.name =
+			of_get_property(child, "label", NULL) ? : child->name;
+		led.default_trigger =
+			of_get_property(child, "linux,default-trigger", NULL);
+		pca995x_leds[reg] = led;
+	}
+	pdata = devm_kzalloc(&client->dev,
+			     sizeof(struct pca995x_platform_data), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+	pr_info("ALL 3\n");
+
+	pdata->leds.leds = pca995x_leds;
+	pdata->leds.num_leds = chip->n_leds;
+
+
+	return pdata;
+}
+
+static const struct of_device_id of_pca995x_match[] = {
+	{ .compatible = "nxp,pca9955", },
+	{},
+};
+#else
+static struct pca995x_platform_data *
+pca995x_dt_init(struct i2c_client *client, struct pca995x_chipdef *chip)
+{
+	return ERR_PTR(-ENODEV);
+}
+#endif
+
+static int pca995x_probe(struct i2c_client *client,
+					const struct i2c_device_id *id)
+{
+	struct pca995x *pca995x_chip;
+	struct pca995x_led *pca995x;
+	struct pca995x_platform_data *pdata;
+	struct pca995x_chipdef *chip;
+	int i, err;
+
+	chip = &pca995x_chipdefs[id->driver_data];
+	pdata = dev_get_platdata(&client->dev);
+
+	if (!pdata) {
+		pdata = pca995x_dt_init(client, chip);
+		if (IS_ERR(pdata)) {
+			dev_warn(&client->dev, "could not parse configuration\n");
+			pdata = NULL;
+		}
+	}
+
+	if (pdata && (pdata->leds.num_leds < 1 ||
+				 pdata->leds.num_leds > chip->n_leds)) {
+		dev_err(&client->dev, "board info must claim 1-%d LEDs",
+								chip->n_leds);
+		return -EINVAL;
+	}
+
+	pca995x_chip = devm_kzalloc(&client->dev, sizeof(*pca995x_chip),
+								GFP_KERNEL);
+	if (!pca995x_chip)
+		return -ENOMEM;
+	pca995x = devm_kzalloc(&client->dev, chip->n_leds * sizeof(*pca995x),
+								GFP_KERNEL);
+	if (!pca995x)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, pca995x_chip);
+
+	mutex_init(&pca995x_chip->mutex);
+	pca995x_chip->chipdef = chip;
+	pca995x_chip->client = client;
+	pca995x_chip->leds = pca995x;
+
+	/* Turn off LEDs by default*/
+	for (i = 0; i < chip->n_leds / 4; i++)
+		i2c_smbus_write_byte_data(client, chip->ledout_base + i, 0x00);
+
+	for (i = 0; i < chip->n_leds; i++) {
+		pca995x[i].led_num = i;
+		pca995x[i].chip = pca995x_chip;
+
+		/* Platform data can specify LED names and default triggers */
+		if (pdata && i < pdata->leds.num_leds) {
+			if (pdata->leds.leds[i].name)
+				snprintf(pca995x[i].name,
+					 sizeof(pca995x[i].name), "pca995x:%s",
+					 pdata->leds.leds[i].name);
+			if (pdata->leds.leds[i].default_trigger)
+				pca995x[i].led_cdev.default_trigger =
+					pdata->leds.leds[i].default_trigger;
+		}
+		if (!pdata || i >= pdata->leds.num_leds ||
+						!pdata->leds.leds[i].name)
+			snprintf(pca995x[i].name, sizeof(pca995x[i].name),
+				 "pca995x:%d:%.2x:%d", client->adapter->nr,
+				 client->addr, i);
+
+		pca995x[i].led_cdev.name = pca995x[i].name;
+		pca995x[i].led_cdev.brightness_set = pca995x_led_set;
+
+		if (pdata && pdata->blink_type == PCA963X_HW_BLINK)
+			pca995x[i].led_cdev.blink_set = pca995x_blink_set;
+
+		INIT_WORK(&pca995x[i].work, pca995x_work);
+
+		err = led_classdev_register(&client->dev, &pca995x[i].led_cdev);
+		if (err < 0)
+			goto exit;
+	}
+
+	/* Disable LED all-call address and set normal mode */
+	i2c_smbus_write_byte_data(client, PCA963X_MODE1, 0x00);
+	/*IREF Output current value for all LEDn outputs*/
+	i2c_smbus_write_byte_data(client, PCA963X_IREFALL, 0x7F);
+
+
+	return 0;
+
+exit:
+	while (i--) {
+		led_classdev_unregister(&pca995x[i].led_cdev);
+		cancel_work_sync(&pca995x[i].work);
+	}
+
+	return err;
+}
+
+static int pca995x_remove(struct i2c_client *client)
+{
+	struct pca995x *pca995x = i2c_get_clientdata(client);
+	int i;
+
+	for (i = 0; i < pca995x->chipdef->n_leds; i++) {
+		led_classdev_unregister(&pca995x->leds[i].led_cdev);
+		cancel_work_sync(&pca995x->leds[i].work);
+	}
+
+	return 0;
+}
+
+static struct i2c_driver pca995x_driver = {
+	.driver = {
+		.name	= "leds-pca995x",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(of_pca995x_match),
+	},
+	.probe	= pca995x_probe,
+	.remove	= pca995x_remove,
+	.id_table = pca995x_id,
+};
+
+module_i2c_driver(pca995x_driver);
+
+MODULE_AUTHOR("Alejandro Lozano <alejandro.lozano@nxp.com>");
+MODULE_DESCRIPTION("PCA995x LED driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/linux/platform_data/leds-pca995x.h b/include/linux/platform_data/leds-pca995x.h
new file mode 100644
index 0000000..977df9f
--- /dev/null
+++ b/include/linux/platform_data/leds-pca995x.h
@@ -0,0 +1,42 @@
+/*
+ * PCA963X LED chip driver.
+ *
+ * Copyright 2012 bct electronic GmbH
+ * Copyright 2013 Qtechnology A/S
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#ifndef __LINUX_PCA963X_H
+#define __LINUX_PCA963X_H
+#include <linux/leds.h>
+
+enum pca995x_outdrv {
+	PCA963X_OPEN_DRAIN,
+	PCA963X_TOTEM_POLE, /* aka push-pull */
+};
+
+enum pca995x_blink_type {
+	PCA963X_SW_BLINK,
+	PCA963X_HW_BLINK,
+};
+
+struct pca995x_platform_data {
+	struct led_platform_data leds;
+	enum pca995x_outdrv outdrv;
+	enum pca995x_blink_type blink_type;
+};
+
+#endif /* __LINUX_PCA963X_H*/
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 0d6f568..593164a 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -123,6 +123,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_RT5670 if I2C
 	select SND_SOC_RT5677 if I2C && SPI_MASTER
 	select SND_SOC_SGTL5000 if I2C
+	select SND_SOC_SPH0645
 	select SND_SOC_SI476X if MFD_SI476X_CORE
 	select SND_SOC_SIRF_AUDIO_CODEC
 	select SND_SOC_SN95031 if INTEL_SCU_IPC
@@ -762,6 +763,10 @@ config SND_SOC_SGTL5000
 	tristate "Freescale SGTL5000 CODEC"
 	depends on I2C
 
+config SND_SOC_SPH0645
+       tristate "Freescale SPH0645 CODEC"
+       default y
+
 config SND_SOC_SI476X
 	tristate
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index bd1385e..2277456 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -125,6 +125,7 @@ snd-soc-rt5670-objs := rt5670.o
 snd-soc-rt5677-objs := rt5677.o
 snd-soc-rt5677-spi-objs := rt5677-spi.o
 snd-soc-sgtl5000-objs := sgtl5000.o
+snd-soc-sph0645-objs := sph0645.o
 snd-soc-alc5623-objs := alc5623.o
 snd-soc-alc5632-objs := alc5632.o
 snd-soc-sigmadsp-objs := sigmadsp.o
@@ -356,6 +357,7 @@ obj-$(CONFIG_SND_SOC_RT5670)	+= snd-soc-rt5670.o
 obj-$(CONFIG_SND_SOC_RT5677)	+= snd-soc-rt5677.o
 obj-$(CONFIG_SND_SOC_RT5677_SPI)	+= snd-soc-rt5677-spi.o
 obj-$(CONFIG_SND_SOC_SGTL5000)  += snd-soc-sgtl5000.o
+obj-$(CONFIG_SND_SOC_SPH0645)  += snd-soc-sph0645.o
 obj-$(CONFIG_SND_SOC_SIGMADSP)	+= snd-soc-sigmadsp.o
 obj-$(CONFIG_SND_SOC_SIGMADSP_I2C)	+= snd-soc-sigmadsp-i2c.o
 obj-$(CONFIG_SND_SOC_SIGMADSP_REGMAP)	+= snd-soc-sigmadsp-regmap.o
diff --git a/sound/soc/codecs/sph0645.c b/sound/soc/codecs/sph0645.c
new file mode 100644
index 0000000..bf4f2a6
--- /dev/null
+++ b/sound/soc/codecs/sph0645.c
@@ -0,0 +1,76 @@
+/*
+ * I2S MEMS microphone driver for SPH0645
+ *
+ * - Non configurable.
+ * - I2S interface 24 bit data
+ *
+ * Copyright (c) 2015 Axis Communications AB
+ *
+ * Licensed under GPL v2.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#define SPH0645_RATE_MIN 32000 /* 7190  Hz, from data sheet */
+#define SPH0645_RATE_MAX 64000 /* 52800 Hz, from data sheet */
+
+#define SPH0645_FORMATS (SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S32 ) //SNDRV_PCM_FMTBIT_S32
+
+static struct snd_soc_dai_driver sph0645_dai = {
+	.name = "sph0645",
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rate_min = SPH0645_RATE_MIN,
+		.rate_max = SPH0645_RATE_MAX,
+		.rates = SNDRV_PCM_RATE_CONTINUOUS,
+		.formats = SPH0645_FORMATS,
+	},
+};
+
+static struct snd_soc_codec_driver sph0645_codec_driver = {
+};
+
+static int sph0645_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, &sph0645_codec_driver,
+			&sph0645_dai, 1);
+}
+
+static int sph0645_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id sph0645_ids[] = {
+	{ .compatible = "knowles,sph0645", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, sph0645_ids);
+#endif
+
+static struct platform_driver sph0645_driver = {
+	.driver = {
+		.name = "sph0645",
+		.of_match_table = of_match_ptr(sph0645_ids),
+	},
+	.probe = sph0645_probe,
+	.remove = sph0645_remove,
+};
+
+module_platform_driver(sph0645_driver);
+
+MODULE_DESCRIPTION("ASoC SPH0645 driver");
+MODULE_AUTHOR("Alejandro Lozano <alejandro.lozano@nxp.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/fsl/Kconfig b/sound/soc/fsl/Kconfig
index 745139f..7f0bb34 100644
--- a/sound/soc/fsl/Kconfig
+++ b/sound/soc/fsl/Kconfig
@@ -441,6 +441,19 @@ config SND_SOC_IMX_SGTL5000
 	  Say Y if you want to add support for SoC audio on an i.MX board with
 	  a sgtl5000 codec.
 
+config SND_SOC_IMX_TFA98XX
+       tristate "Soc Audio support for i.MX boards with NXP TFA98XX"
+       depends on OF && I2C
+       select SND_SOC_TFA98XX
+       select SND_SOC_IMX_PCM_DMA
+       select SND_SOC_IMX_AUDMUX
+
+config SND_SOC_IMX_SPH0645
+       tristate "Soc Audio support for i.MX boards with NXP SPH06455"
+       select SND_SOC_SPH0645
+       select SND_SOC_IMX_PCM_DMA
+       select SND_SOC_IMX_AUDMUX
+
 config SND_SOC_IMX_MQS
 	tristate "SoC Audio support for i.MX boards with MQS"
 	depends on OF
diff --git a/sound/soc/fsl/Makefile b/sound/soc/fsl/Makefile
index ea77ae4b..6af6a25 100644
--- a/sound/soc/fsl/Makefile
+++ b/sound/soc/fsl/Makefile
@@ -68,6 +68,8 @@ snd-soc-wm1133-ev1-objs := wm1133-ev1.o
 snd-soc-imx-es8328-objs := imx-es8328.o
 snd-soc-imx-cs42888-objs := imx-cs42888.o
 snd-soc-imx-sgtl5000-objs := imx-sgtl5000.o
+snd-soc-imx-tfa98xx-objs := imx-tfa98xx.o
+snd-soc-imx-sph0645-objs := imx-sph0645.o
 snd-soc-imx-wm8958-objs := imx-wm8958.o
 snd-soc-imx-wm8960-objs := imx-wm8960.o
 snd-soc-imx-wm8524-objs := imx-wm8524.o
@@ -94,6 +96,8 @@ obj-$(CONFIG_SND_MXC_SOC_WM1133_EV1) += snd-soc-wm1133-ev1.o
 obj-$(CONFIG_SND_SOC_IMX_ES8328) += snd-soc-imx-es8328.o
 obj-$(CONFIG_SND_SOC_IMX_CS42888) += snd-soc-imx-cs42888.o
 obj-$(CONFIG_SND_SOC_IMX_SGTL5000) += snd-soc-imx-sgtl5000.o
+obj-$(CONFIG_SND_SOC_IMX_TFA98XX) += snd-soc-imx-tfa98xx.o
+obj-$(CONFIG_SND_SOC_IMX_SPH0645) += snd-soc-imx-sph0645.o
 obj-${CONFIG_SND_SOC_IMX_WM8958} += snd-soc-imx-wm8958.o
 obj-$(CONFIG_SND_SOC_IMX_WM8960) += snd-soc-imx-wm8960.o
 obj-$(CONFIG_SND_SOC_IMX_WM8524) += snd-soc-imx-wm8524.o
diff --git a/sound/soc/fsl/imx-sph0645.c b/sound/soc/fsl/imx-sph0645.c
new file mode 100644
index 0000000..ff26937
--- /dev/null
+++ b/sound/soc/fsl/imx-sph0645.c
@@ -0,0 +1,407 @@
+/*
+ * ASoC driver for BBB + NXP TFA98xx family of devices
+ *
+ * Author:      Sebastien Jan <sjan@baylibre.com>
+ * Copyright (C) 2015 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DEBUG
+#define pr_fmt(fmt) "%s(): " fmt, __func__
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/of_platform.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/jack.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+
+#include <asm/dma.h>
+#include <asm-generic/types.h>
+
+#define DAI_NAME_SIZE	32
+
+static u32 imx_sph0645_rates[] = { 32000, 48000 };
+static struct snd_pcm_hw_constraint_list imx_sph0645_rate_constraints = {
+	.count = ARRAY_SIZE(imx_sph0645_rates),
+	.list = imx_sph0645_rates,
+};
+
+struct snd_soc_card_drvdata_imx_tfa {
+	struct clk *mclk;
+	struct snd_soc_dai_link *dai;
+	struct snd_soc_card card;
+	char codec_dai_name[DAI_NAME_SIZE];
+	char platform_name[DAI_NAME_SIZE];
+	unsigned int clk_frequency;
+	int pstreams;
+	int cstreams;
+};
+
+static int imx_sph0645_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *soc_card = rtd->card;
+	struct snd_soc_card_drvdata_imx_tfa *drvdata =
+		snd_soc_card_get_drvdata(soc_card);
+	int ret;
+
+	pr_info("\n");
+
+	ret = snd_pcm_hw_constraint_list(substream->runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE, &imx_sph0645_rate_constraints);
+	if (ret)
+		return ret;
+
+	if (drvdata->mclk)
+		return clk_prepare_enable(drvdata->mclk);
+
+	return 0;
+}
+
+static void imx_sph0645_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *soc_card = rtd->card;
+	struct snd_soc_card_drvdata_imx_tfa *drvdata =
+		snd_soc_card_get_drvdata(soc_card);
+
+	pr_info("\n");
+	if (drvdata->mclk)
+		clk_disable_unprepare(drvdata->mclk);
+}
+
+static int imx_sph0645_hw_params(struct snd_pcm_substream *substream,
+			 struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_card_drvdata_imx_tfa *data = snd_soc_card_get_drvdata(rtd->card);
+	u32 channels = params_channels(params);
+	u32 rate = params_rate(params);
+	u32 bclk = rate * channels * 32;
+	int ret = 0;
+
+	/* set cpu DAI configuration SND_SOC_DAIFMT_I2S*/
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S
+			| SND_SOC_DAIFMT_IB_IF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret) {
+		dev_err(cpu_dai->dev, "failed to set cpu dai fmt\n");
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, 0, SND_SOC_CLOCK_OUT);
+	if (ret) {
+		dev_err(cpu_dai->dev, "failed to set cpu sysclk: %d\n", ret);
+		return ret;
+	}
+	return ret;
+}
+
+static int imx_sph0645_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *soc_card = rtd->card;
+	struct snd_soc_card_drvdata_imx_tfa *drvdata =
+		snd_soc_card_get_drvdata(soc_card);
+
+	if (drvdata->pstreams != 0 || drvdata->cstreams != 0)
+		return 0;
+
+	return 0;
+}
+
+static int imx_sph0645_trigger(struct snd_pcm_substream *stream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = stream->private_data;
+	struct snd_soc_card_drvdata_imx_tfa *drvdata =
+		snd_soc_card_get_drvdata(rtd->card);
+	int ret = 0;
+
+	pr_info("\n");
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		if (stream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			drvdata->pstreams++;
+		else
+			drvdata->cstreams++;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		if (stream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			if (drvdata->pstreams > 0)
+				drvdata->pstreams--;
+			else
+				pr_err("Error in playback streams count\n");
+		} else {
+			if (drvdata->cstreams > 0)
+				drvdata->cstreams--;
+			else
+				pr_err("Error in capture streams count\n");
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops imx_sph0645_ops = {
+	.startup = imx_sph0645_startup,
+	.shutdown = imx_sph0645_shutdown,
+	.hw_params = imx_sph0645_hw_params,
+	.hw_free = imx_sph0645_hw_free,
+	.trigger = imx_sph0645_trigger,
+};
+
+static int imx_sph0645_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_card_drvdata_imx_tfa *data = snd_soc_card_get_drvdata(rtd->card);;
+	struct device *dev = rtd->card->dev;
+
+	pr_info("\n");
+	dev_dbg(rtd->card->dev, "%s,%d: dai_init\n", __FUNCTION__, __LINE__);
+
+	return 0;
+}
+
+static void *tfa_devm_kstrdup(struct device *dev, char *buf)
+{
+	char *str = devm_kzalloc(dev, strlen(buf) + 1, GFP_KERNEL);
+
+	pr_info("\n");
+	if (!str)
+		return str;
+	memcpy(str, buf, strlen(buf));
+	return str;
+}
+
+#if defined(CONFIG_OF)
+/*
+ * The structs are used as place holders. They will be completely
+ * filled with data from dt node.
+ */
+	
+static struct snd_soc_dai_link imx_dai_sph0645[] = {
+	{
+		.name		= "HiFi",
+		.stream_name	= "HiFi",
+		.ops            = &imx_sph0645_ops,
+		.init           = imx_sph0645_init,
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBS_CFS |
+			SND_SOC_DAIFMT_NB_NF,
+	},
+};
+
+static const struct of_device_id imx_tfa98_dt_ids[] = {
+	{
+		.compatible = "nxp,imx-audio-sph0645",
+		.data = &imx_dai_sph0645,
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_tfa98_dt_ids);
+
+static const struct snd_soc_dapm_widget imx_sph0645_widgets[] = {
+//	SND_SOC_DAPM_SPK("Speaker", NULL),
+//	SND_SOC_DAPM_MIC("Mic", NULL),
+};
+
+static const struct snd_kcontrol_new imx_sph0645_controls[] = {
+};
+
+static struct snd_soc_card imx_sph0645_soc_card = {
+	.owner = THIS_MODULE,
+	.name = "SPH0645",	/* default name if none defined in DT */
+	.dai_link = imx_dai_sph0645,
+	.num_links = ARRAY_SIZE(imx_dai_sph0645),
+	.controls = imx_sph0645_controls,
+	.num_controls = ARRAY_SIZE(imx_sph0645_controls),
+	.dapm_widgets = imx_sph0645_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(imx_sph0645_widgets),
+};
+
+static int imx_sph0645_probe(struct platform_device *pdev)
+{
+	struct device_node *cpu_np, *np = pdev->dev.of_node;
+	struct platform_device *cpu_pdev;
+	struct snd_soc_dai_link_component *codecs;
+	struct i2c_client *codec_dev;
+	struct snd_soc_dai_link *dai;
+	struct snd_soc_card_drvdata_imx_tfa *drvdata = NULL;
+	struct clk *mclk;
+	int ret = 0;
+	int i, num_codecs;
+
+	pr_info("imx_sph0645_probe\n");
+
+	imx_sph0645_soc_card.dev = &pdev->dev;
+
+	cpu_np = of_parse_phandle(pdev->dev.of_node, "cpu-dai", 0);
+	if (!cpu_np) {
+		dev_err(&pdev->dev, "cpu dai phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	cpu_pdev = of_find_device_by_node(cpu_np);
+	if (!cpu_pdev) {
+		dev_err(&pdev->dev, "failed to find SAI platform device\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+	ret = snd_soc_of_parse_card_name(&imx_sph0645_soc_card, "nxp,model");
+	if (ret)
+		goto fail;;
+	num_codecs = of_count_phandle_with_args(np, "nxp,audio-codec", NULL);
+	if (num_codecs < 1) {
+		ret = -EINVAL;
+		goto fail;
+	}
+	pr_info("Found %d codec(s)\n", num_codecs);
+
+	codecs = devm_kzalloc(&pdev->dev,
+			sizeof(struct snd_soc_dai_link_component) * num_codecs,
+			GFP_KERNEL);
+
+	if (!codecs) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	for (i = 0; i < num_codecs; i++) {
+		struct device_node *parent;
+		int id;
+		const u32 *property;
+		int len;
+		char name[18];
+
+		codecs[i].of_node = of_parse_phandle(np, "nxp,audio-codec", i);
+		snprintf(name, sizeof(name), "sph0645");
+		codecs[i].dai_name = tfa_devm_kstrdup(&pdev->dev, name);
+	}
+	dai = &imx_dai_sph0645[0];
+	dai->platform_of_node = cpu_np;
+	dai->codecs = codecs;
+	dai->cpu_dai_name = dev_name(&cpu_pdev->dev);
+	dai->num_codecs = num_codecs;
+	dai->cpu_of_node = of_parse_phandle(np, "ssi-controller", 0);
+	if (!dai->cpu_of_node) {
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	/* Only set the platform_of_node if the platform_name is not set */
+	if (!dai->platform_name)
+		dai->platform_of_node = dai->cpu_of_node;
+
+	mclk = devm_clk_get(&pdev->dev, NULL);
+	if (PTR_ERR(mclk) == -EPROBE_DEFER) {
+		pr_info("getting clk defered\n");
+		return -EPROBE_DEFER;
+	} else if (IS_ERR(mclk)) {
+		dev_dbg(&pdev->dev, "clock not found.\n");
+		mclk = NULL;
+	}
+
+	drvdata = devm_kzalloc(&pdev->dev, sizeof(*drvdata), GFP_KERNEL);
+	if (!drvdata) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	if (mclk) {
+		pr_info("Reference clock found: %s @ %ld\n",
+			__clk_get_name(mclk),clk_get_rate(mclk));
+		clk_prepare(mclk);
+		clk_enable(mclk);
+		drvdata->mclk = mclk;
+	}
+	drvdata->clk_frequency = clk_get_rate(drvdata->mclk);
+	drvdata->dai = dai;
+
+	platform_set_drvdata(pdev, &drvdata->card);
+	snd_soc_card_set_drvdata(&imx_sph0645_soc_card, drvdata);
+
+	ret = devm_snd_soc_register_card(&pdev->dev, &imx_sph0645_soc_card);
+	if (ret)
+		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
+
+	pr_info("done\n");
+	return ret;
+fail:
+	if (cpu_np)
+		of_node_put(cpu_np);
+#if 0
+	if (codecs)
+		of_node_put(codecs);
+#endif
+
+	return ret;
+}
+
+static int imx_sph0645_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct snd_soc_card_drvdata_imx_tfa *drvdata =
+				snd_soc_card_get_drvdata(card);
+
+	pr_info("\n");
+
+	if (drvdata->mclk)
+		clk_disable(drvdata->mclk);
+
+	return 0;
+}
+
+static struct platform_driver imx_sph0645_driver = {
+	.probe		= imx_sph0645_probe,
+	.remove		= imx_sph0645_remove,
+	.driver		= {
+		.name	= "imx-sph0645",
+		.owner	= THIS_MODULE,
+		.pm	= &snd_soc_pm_ops,
+		.of_match_table = of_match_ptr(imx_tfa98_dt_ids),
+	},
+};
+#endif
+
+static int __init _sph0645_init(void)
+{
+#if defined(CONFIG_OF)
+	if (of_have_populated_dt())
+		return platform_driver_register(&imx_sph0645_driver);
+#endif
+	return 0;
+}
+
+static void __exit _sph0645_exit(void)
+{
+#if defined(CONFIG_OF)
+	if (of_have_populated_dt()) {
+		platform_driver_unregister(&imx_sph0645_driver);
+		return;
+	}
+#endif
+}
+
+module_init(_sph0645_init);
+module_exit(_sph0645_exit);
+
+MODULE_AUTHOR("Alejandro Lozano");
+MODULE_DESCRIPTION("i.MX7d SPH0645 I2S MEMS driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/fsl/imx-tfa98xx.c b/sound/soc/fsl/imx-tfa98xx.c
new file mode 100644
index 0000000..20ee4f2
--- /dev/null
+++ b/sound/soc/fsl/imx-tfa98xx.c
@@ -0,0 +1,430 @@
+/*
+ * ASoC driver for BBB + NXP TFA98xx family of devices
+ *
+ * Author:      Sebastien Jan <sjan@baylibre.com>
+ * Copyright (C) 2015 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DEBUG
+#define pr_fmt(fmt) "%s(): " fmt, __func__
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/of_platform.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/jack.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+
+#include <asm/dma.h>
+#include <asm-generic/types.h>
+
+#define DAI_NAME_SIZE	32
+
+static u32 imx_tfa98xx_rates[] = { 8000, 16000, 32000, 44100, 48000 };
+static struct snd_pcm_hw_constraint_list imx_tfa98xx_rate_constraints = {
+	.count = ARRAY_SIZE(imx_tfa98xx_rates),
+	.list = imx_tfa98xx_rates,
+};
+
+struct snd_soc_card_drvdata_imx_tfa {
+	struct clk *mclk;
+	struct snd_soc_dai_link *dai;
+	struct snd_soc_card card;
+	char codec_dai_name[DAI_NAME_SIZE];
+	char platform_name[DAI_NAME_SIZE];
+	unsigned int clk_frequency;
+	int pstreams;
+	int cstreams;
+};
+
+static int imx_tfa98xx_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *soc_card = rtd->card;
+	struct snd_soc_card_drvdata_imx_tfa *drvdata =
+		snd_soc_card_get_drvdata(soc_card);
+	int ret;
+
+	pr_info("\n");
+
+	ret = snd_pcm_hw_constraint_list(substream->runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE, &imx_tfa98xx_rate_constraints);
+	if (ret)
+		return ret;
+
+	if (drvdata->mclk)
+		return clk_prepare_enable(drvdata->mclk);
+
+	return 0;
+}
+
+static void imx_tfa98xx_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *soc_card = rtd->card;
+	struct snd_soc_card_drvdata_imx_tfa *drvdata =
+		snd_soc_card_get_drvdata(soc_card);
+
+	pr_info("\n");
+	if (drvdata->mclk)
+		clk_disable_unprepare(drvdata->mclk);
+}
+
+static int imx_tfa98xx_hw_params(struct snd_pcm_substream *substream,
+			 struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_card_drvdata_imx_tfa *data = snd_soc_card_get_drvdata(rtd->card);
+	u32 channels = params_channels(params);
+	u32 rate = params_rate(params);
+	u32 bclk = rate * channels * 32;
+	int ret = 0;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S
+			| SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret) {
+		dev_err(cpu_dai->dev, "failed to set cpu dai fmt\n");
+		return ret;
+	}
+	ret = snd_soc_dai_set_fmt(rtd->codec_dai, SND_SOC_DAIFMT_I2S
+			| SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	
+	if (ret) {
+		dev_err(cpu_dai->dev, "failed to set codec dai fmt\n");
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_tdm_slot(cpu_dai, 0, 0, 2, params_width(params));
+	if (ret) {
+		dev_err(cpu_dai->dev, "failed to set cpu dai tdm slot: %d\n", ret);
+		return ret;
+	}
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, 0, SND_SOC_CLOCK_OUT);
+	if (ret) {
+		dev_err(cpu_dai->dev, "failed to set cpu sysclk: %d\n", ret);
+		return ret;
+	}
+	return ret;
+}
+
+static int imx_tfa98xx_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *soc_card = rtd->card;
+	struct snd_soc_card_drvdata_imx_tfa *drvdata =
+		snd_soc_card_get_drvdata(soc_card);
+
+	if (drvdata->pstreams != 0 || drvdata->cstreams != 0)
+		return 0;
+
+	return 0;
+}
+
+static int imx_tfa98xx_trigger(struct snd_pcm_substream *stream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = stream->private_data;
+	struct snd_soc_card_drvdata_imx_tfa *drvdata =
+		snd_soc_card_get_drvdata(rtd->card);
+	int ret = 0;
+
+	pr_info("\n");
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		if (stream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			drvdata->pstreams++;
+		else
+			drvdata->cstreams++;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		if (stream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			if (drvdata->pstreams > 0)
+				drvdata->pstreams--;
+			else
+				pr_err("Error in playback streams count\n");
+		} else {
+			if (drvdata->cstreams > 0)
+				drvdata->cstreams--;
+			else
+				pr_err("Error in capture streams count\n");
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops imx_tfa98xx_ops = {
+	.startup = imx_tfa98xx_startup,
+	.shutdown = imx_tfa98xx_shutdown,
+	.hw_params = imx_tfa98xx_hw_params,
+	.hw_free = imx_tfa98xx_hw_free,
+	.trigger = imx_tfa98xx_trigger,
+};
+
+static int imx_tfa98xx_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_card_drvdata_imx_tfa *data = snd_soc_card_get_drvdata(rtd->card);;
+	struct device *dev = rtd->card->dev;
+
+	pr_info("\n");
+	dev_dbg(rtd->card->dev, "%s,%d: dai_init\n", __FUNCTION__, __LINE__);
+
+	return 0;
+}
+
+static void *tfa_devm_kstrdup(struct device *dev, char *buf)
+{
+	char *str = devm_kzalloc(dev, strlen(buf) + 1, GFP_KERNEL);
+
+	pr_info("\n");
+	if (!str)
+		return str;
+	memcpy(str, buf, strlen(buf));
+	return str;
+}
+
+#if defined(CONFIG_OF)
+/*
+ * The structs are used as place holders. They will be completely
+ * filled with data from dt node.
+ */
+	
+static struct snd_soc_dai_link imx_dai_tfa98xx[] = {
+	{
+		.name		= "HiFi",
+		.stream_name	= "HiFi",
+		.ops            = &imx_tfa98xx_ops,
+		.init           = imx_tfa98xx_init,
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBS_CFS |
+			SND_SOC_DAIFMT_NB_NF,
+	},
+};
+
+static const struct of_device_id imx_tfa98_dt_ids[] = {
+	{
+		.compatible = "nxp,imx-audio-tfa98xx",
+		.data = &imx_dai_tfa98xx,
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_tfa98_dt_ids);
+
+static const struct snd_soc_dapm_widget imx_tfa98xx_widgets[] = {
+	SND_SOC_DAPM_SPK("Speaker", NULL),
+	SND_SOC_DAPM_MIC("Mic", NULL),
+};
+
+static const struct snd_kcontrol_new imx_tfa98xx_controls[] = {
+};
+
+static struct snd_soc_card imx_tfa98xx_soc_card = {
+	.owner = THIS_MODULE,
+	.name = "TFA9912",	/* default name if none defined in DT */
+	.dai_link = imx_dai_tfa98xx,
+	.num_links = ARRAY_SIZE(imx_dai_tfa98xx),
+	.controls = imx_tfa98xx_controls,
+	.num_controls = ARRAY_SIZE(imx_tfa98xx_controls),
+	.dapm_widgets = imx_tfa98xx_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(imx_tfa98xx_widgets),
+};
+
+static int imx_tfa98xx_probe(struct platform_device *pdev)
+{
+	struct device_node *cpu_np, *np = pdev->dev.of_node;
+	struct platform_device *cpu_pdev;
+	struct snd_soc_dai_link_component *codecs;
+	struct i2c_client *codec_dev;
+	struct snd_soc_dai_link *dai;
+	struct snd_soc_card_drvdata_imx_tfa *drvdata = NULL;
+	struct clk *mclk;
+	int ret = 0;
+	int i, num_codecs;
+
+	pr_info("\n");
+
+	imx_tfa98xx_soc_card.dev = &pdev->dev;
+
+	cpu_np = of_parse_phandle(pdev->dev.of_node, "cpu-dai", 0);
+	if (!cpu_np) {
+		dev_err(&pdev->dev, "cpu dai phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	cpu_pdev = of_find_device_by_node(cpu_np);
+	if (!cpu_pdev) {
+		dev_err(&pdev->dev, "failed to find SAI platform device\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+	ret = snd_soc_of_parse_card_name(&imx_tfa98xx_soc_card, "nxp,model");
+	if (ret)
+		goto fail;;
+
+	ret = snd_soc_of_parse_audio_routing(&imx_tfa98xx_soc_card, "nxp,audio-routing");
+	if (ret)
+		goto fail;
+
+	num_codecs = of_count_phandle_with_args(np, "nxp,audio-codec", NULL);
+	if (num_codecs < 1) {
+		ret = -EINVAL;
+		goto fail;
+	}
+	pr_info("Found %d codec(s)\n", num_codecs);
+
+	codecs = devm_kzalloc(&pdev->dev,
+			sizeof(struct snd_soc_dai_link_component) * num_codecs,
+			GFP_KERNEL);
+
+	if (!codecs) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	for (i = 0; i < num_codecs; i++) {
+		struct device_node *parent;
+		int id;
+		const u32 *property;
+		int len;
+		char name[18];
+
+		codecs[i].of_node = of_parse_phandle(np, "nxp,audio-codec", i);
+		/* get i2c address */
+		property = of_get_property(codecs[i].of_node, "reg", &len);
+		/* get i2c bus */
+		parent = of_get_parent(codecs[i].of_node);
+		id = of_alias_get_id(parent, "i2c");
+		/* construct dai name */
+		snprintf(name, sizeof(name), "tfa98xx-aif-%d-%x", id, be32_to_cpu(property[0]));
+		codecs[i].dai_name = tfa_devm_kstrdup(&pdev->dev, name);
+	}
+	dai = &imx_dai_tfa98xx[0];
+	dai->platform_of_node = cpu_np;
+	dai->codecs = codecs;
+	dai->cpu_dai_name = dev_name(&cpu_pdev->dev);
+	dai->num_codecs = num_codecs;
+	dai->cpu_of_node = of_parse_phandle(np, "ssi-controller", 0);
+	if (!dai->cpu_of_node) {
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	/* Only set the platform_of_node if the platform_name is not set */
+	if (!dai->platform_name)
+		dai->platform_of_node = dai->cpu_of_node;
+
+	mclk = devm_clk_get(&pdev->dev, NULL);
+	if (PTR_ERR(mclk) == -EPROBE_DEFER) {
+		pr_info("getting clk defered\n");
+		return -EPROBE_DEFER;
+	} else if (IS_ERR(mclk)) {
+		dev_dbg(&pdev->dev, "clock not found.\n");
+		mclk = NULL;
+	}
+
+	drvdata = devm_kzalloc(&pdev->dev, sizeof(*drvdata), GFP_KERNEL);
+	if (!drvdata) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	if (mclk) {
+		pr_info("Reference clock found: %s @ %ld\n",
+			__clk_get_name(mclk),clk_get_rate(mclk));
+		clk_prepare(mclk);
+		clk_enable(mclk);
+		drvdata->mclk = mclk;
+	}
+	drvdata->clk_frequency = clk_get_rate(drvdata->mclk);
+	drvdata->dai = dai;
+
+	platform_set_drvdata(pdev, &drvdata->card);
+	snd_soc_card_set_drvdata(&imx_tfa98xx_soc_card, drvdata);
+
+	ret = devm_snd_soc_register_card(&pdev->dev, &imx_tfa98xx_soc_card);
+	if (ret)
+		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
+
+	pr_info("done\n");
+	return ret;
+fail:
+	if (cpu_np)
+		of_node_put(cpu_np);
+#if 0
+	if (codecs)
+		of_node_put(codecs);
+#endif
+
+	return ret;
+}
+
+static int imx_tfa98xx_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct snd_soc_card_drvdata_imx_tfa *drvdata =
+				snd_soc_card_get_drvdata(card);
+
+	pr_info("\n");
+
+	if (drvdata->mclk)
+		clk_disable(drvdata->mclk);
+
+	return 0;
+}
+
+static struct platform_driver imx_tfa98xx_driver = {
+	.probe		= imx_tfa98xx_probe,
+	.remove		= imx_tfa98xx_remove,
+	.driver		= {
+		.name	= "imx-tfa98xx",
+		.owner	= THIS_MODULE,
+		.pm	= &snd_soc_pm_ops,
+		.of_match_table = of_match_ptr(imx_tfa98_dt_ids),
+	},
+};
+#endif
+
+static int __init _tfa98xx_init(void)
+{
+#if defined(CONFIG_OF)
+	if (of_have_populated_dt())
+		return platform_driver_register(&imx_tfa98xx_driver);
+#endif
+	return 0;
+}
+
+static void __exit _tfa98xx_exit(void)
+{
+#if defined(CONFIG_OF)
+	if (of_have_populated_dt()) {
+		platform_driver_unregister(&imx_tfa98xx_driver);
+		return;
+	}
+#endif
+}
+
+module_init(_tfa98xx_init);
+module_exit(_tfa98xx_exit);
+
+MODULE_AUTHOR("Jerry Yoon");
+MODULE_DESCRIPTION("i.MX7d TFA98XX ASoC driver");
+MODULE_LICENSE("GPL");
-- 
2.7.4

