From 76297b1b7e483b4433c8f84493550a6b0d904b7b Mon Sep 17 00:00:00 2001
From: Juan Gutierrez <juan.gutierrez@nxp.com>
Date: Fri, 13 Jul 2018 20:25:54 +0000
Subject: [PATCH] Add loopback to feed the audio of external app to AWWELib

Signed-off-by: Juan Gutierrez <juan.gutierrez@nxp.com>
---
 .../include/SampleApp/PortAudioMicrophoneWrapper.h |   3 +
 SampleApp/src/PortAudioMicrophoneWrapper.cpp       | 158 ++++++++++++++++++++-
 2 files changed, 160 insertions(+), 1 deletion(-)

diff --git a/SampleApp/include/SampleApp/PortAudioMicrophoneWrapper.h b/SampleApp/include/SampleApp/PortAudioMicrophoneWrapper.h
index 2d50dca..d8a3a0f 100644
--- a/SampleApp/include/SampleApp/PortAudioMicrophoneWrapper.h
+++ b/SampleApp/include/SampleApp/PortAudioMicrophoneWrapper.h
@@ -128,6 +128,9 @@ private:
      * threads.
      */
     std::mutex m_mutex;
+
+
+    void enable_loopback();
 };
 
 }  // namespace sampleApp
diff --git a/SampleApp/src/PortAudioMicrophoneWrapper.cpp b/SampleApp/src/PortAudioMicrophoneWrapper.cpp
index cba9e52..1d602fb 100644
--- a/SampleApp/src/PortAudioMicrophoneWrapper.cpp
+++ b/SampleApp/src/PortAudioMicrophoneWrapper.cpp
@@ -13,6 +13,8 @@
  * permissions and limitations under the License.
  */
 
+#include <stdio.h>
+
 #include <cstring>
 #include <string>
 
@@ -26,6 +28,27 @@
 #include "TcpIO2.h"
 #include "awelib.h"
 
+#include <alsa/asoundlib.h>
+
+
+#define REC_DEVICE_NAME "looprec"
+#define WRITE_DEVICE_NAME "speakers"
+#define READ_FRAME 768
+#define BUFFER_SIZE (SAMPLE_RATE/2)
+#define PERIOD_SIZE (SAMPLE_RATE/4)
+
+
+static const unsigned int NUM_MEDIA_CHANNELS = 2;
+static const unsigned int NUM_AVS_CHANNELS = 1;
+
+static const unsigned int NUM_HARDWARE_INPUT_CHANNELS = 2;
+static const unsigned int NUM_HARDWARE_OUTPUT_CHANNELS = 2;
+static const unsigned int NUM_AWE_INPUT_CHANNELS = 4; // expect an AWE design with 4 input channels
+static const unsigned int NUM_AWE_OUTPUT_CHANNELS = 3; // expect an AWE design with 3 output channels
+static const unsigned int BLOCK_SIZE = 768;
+static const unsigned int AVS_SAMPLE_RATE = 16000;
+
+
 namespace alexaClientSDK {
 namespace sampleApp {
 
@@ -189,6 +212,9 @@ PortAudioMicrophoneWrapper::~PortAudioMicrophoneWrapper() {
 }
 
 bool PortAudioMicrophoneWrapper::initialize() {
+
+
+
     m_writer = m_audioInputStream->createWriter(avsCommon::avs::AudioInputStream::Writer::Policy::NONBLOCKABLE);
     if (!m_writer) {
         ACSDK_CRITICAL(LX("Failed to create stream writer"));
@@ -348,9 +374,105 @@ bool PortAudioMicrophoneWrapper::initialize() {
         return false;
     }
 #endif
+
+	enable_loopback();
+
     return true;
 }
 
+
+snd_pcm_t *handle;
+
+short buffer[READ_FRAME * 2 * 4];
+int aweInBuffer[READ_FRAME * NUM_AWE_INPUT_CHANNELS];
+int aweOutBuffer[READ_FRAME * NUM_AWE_INPUT_CHANNELS];
+
+void PortAudioMicrophoneWrapper::enable_loopback()
+{
+    int err;
+    int dir;
+//    int ret = -1;
+    unsigned int sampleRate = SAMPLE_RATE;
+    snd_pcm_uframes_t periodSize = PERIOD_SIZE;
+    snd_pcm_uframes_t bufferSize = BUFFER_SIZE;
+//    int count = 0;
+//    int error = 0;
+
+		snd_pcm_hw_params_t *params;
+
+
+    err = snd_pcm_open(&handle, REC_DEVICE_NAME, SND_PCM_STREAM_CAPTURE, 0);
+    if (err)
+    {
+        printf( "Unable to open capture PCM device: \n");
+        goto error;
+    }
+
+    snd_pcm_hw_params_alloca(&params);
+
+    snd_pcm_hw_params_any(handle, params);
+
+    err = snd_pcm_hw_params_set_access(handle, params, SND_PCM_ACCESS_RW_INTERLEAVED);
+    if (err)
+    {
+        printf("1Error setting interleaved mode\n");
+        goto error;
+    }
+
+    err = snd_pcm_hw_params_set_format(handle, params, SND_PCM_FORMAT_S16_LE);
+    if (err)
+    {
+        printf("1Error setting format: %s\n", snd_strerror(err));
+        goto error;
+    }
+
+    err = snd_pcm_hw_params_set_channels(handle, params, 2);
+    if (err)
+    {
+        printf( "Error setting channels: %s\n", snd_strerror(err));
+        goto error;
+    }
+
+    err = snd_pcm_hw_params_set_buffer_size_near(handle, params, &bufferSize);
+    if (err)
+    {
+        printf("Error setting buffer size (%ld): %s\n", bufferSize, snd_strerror(err));
+        goto error;
+    }
+
+    err = snd_pcm_hw_params_set_period_size_near(handle, params, &periodSize, 0);
+    if (err)
+    {
+        printf("Error setting period time (%ld): %s\n", periodSize, snd_strerror(err));
+        goto error;
+    }
+
+    err = snd_pcm_hw_params_set_rate_near(handle, params, &sampleRate, &dir);
+    if (err)
+    {
+        printf("Error setting sampling rate (%d): %s\n", sampleRate, snd_strerror(err));
+        goto error;
+    }
+
+    /* Write the parameters to the driver */
+    err = snd_pcm_hw_params(handle, params);
+    if (err < 0)
+    {
+        printf( "Unable to set HW parameters: %s\n", snd_strerror(err));
+        goto error;
+    }
+
+        printf(" open record device done \n");
+
+	return;
+
+error:
+
+	printf("============ ERROR ==================\n");
+	return;
+
+}
+
 bool PortAudioMicrophoneWrapper::startStreamingMicrophoneData() {
     std::lock_guard<std::mutex> lock{m_mutex};
 
@@ -395,6 +517,22 @@ int PortAudioMicrophoneWrapper::PortAudioHardwareCallback(
     SAMPLE aweOutBuffer[BLOCK_SIZE * NUM_AWE_OUTPUT_CHANNELS];
     short avsInBuffer[BLOCK_SIZE * NUM_AWE_OUTPUT_CHANNELS/DECIMATION_FACTOR];
 
+
+
+       int err = snd_pcm_readi(handle, buffer, READ_FRAME);
+//		printf(" bufer = %x %x %x %x", buffer[0], buffer[1], buffer[3], buffer[4]);
+        if (err == -EPIPE) printf( "Overrun occurred: %d\n", err);
+        if (err < 0) {
+            err = snd_pcm_recover(handle, err, 0);
+            // Still an error, need to exit.
+            if (err < 0)
+            {
+                printf( "Error occured while recording: %s\n", snd_strerror(err));
+            }
+        }
+
+
+
     if (numSamples != BLOCK_SIZE) {
         printf("[PortAudioHardwareCallback] Received %lu but expected %u\n", numSamples, BLOCK_SIZE);
         exit(1);
@@ -408,7 +546,8 @@ int PortAudioMicrophoneWrapper::PortAudioHardwareCallback(
     wrapper->m_alertsMediaPlayer->tryPullAppSink(alertsMediaPlayerBuffer, BLOCK_SIZE * NUM_MEDIA_CHANNELS * sizeof(Sample));
 
     for (i =0; i < (BLOCK_SIZE * NUM_MEDIA_CHANNELS); i++) {
-        avsOutBuffer[i] = speakMediaPlayerBuffer[i] + audioMediaPlayerBuffer[i] + alertsMediaPlayerBuffer[i];
+//        avsOutBuffer[i] = speakMediaPlayerBuffer[i] + audioMediaPlayerBuffer[i] + alertsMediaPlayerBuffer[i];
+		  avsOutBuffer[i] = buffer[i];
     }
 
     // Prepare AWE buffer
@@ -501,13 +640,30 @@ int PortAudioMicrophoneWrapper::PortAudioHardwareCallback(
         }
     }
 
+
+#if 0
     // Prepare hardware output buffer
     for (channel = 0; channel < NUM_HARDWARE_OUTPUT_CHANNELS; channel++) {
         for (i = 0; i < BLOCK_SIZE; i++) {
             ((SAMPLE *) speakerBuffer)[i*NUM_HARDWARE_OUTPUT_CHANNELS+channel] = aweOutBuffer[(i*NUM_AWE_OUTPUT_CHANNELS) + (channel+NUM_AVS_CHANNELS)];
         }
     }
+#endif
 
+
+#if 1
+    for (i =0; i < (BLOCK_SIZE * NUM_MEDIA_CHANNELS); i++) {
+//        avsOutBuffer[i] = speakMediaPlayerBuffer[i] + audioMediaPlayerBuffer[i] + alertsMediaPlayerBuffer[i];
+         ((SAMPLE *) speakerBuffer)[i] = speakMediaPlayerBuffer[i] + audioMediaPlayerBuffer[i] + alertsMediaPlayerBuffer[i];
+    }
+#endif
+
+#if testing
+    for (i =0; i < (BLOCK_SIZE * NUM_MEDIA_CHANNELS); i++) {
+//        avsOutBuffer[i] = speakMediaPlayerBuffer[i] + audioMediaPlayerBuffer[i] + alertsMediaPlayerBuffer[i];
+         ((SAMPLE *) speakerBuffer)[i] = buffer[i];
+    }
+#endif
     // Prepare SDS buffer
     channel = 0;
     for (i = 0; i < BLOCK_SIZE/DECIMATION_FACTOR; i++) {
-- 
1.9.1

